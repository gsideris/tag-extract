// Generated by CoffeeScript 1.7.1
$.fn.extend({
  tagExtract: function(options) {
    var opts, self;
    self = $.fn.tagExtract;
    opts = $.extend({}, self.default_options, options);
    return $(this).each(function(i, el) {
      return self.init(el, opts);
    });
  }
});

$.extend($.fn.tagExtract, {
  default_options: {
    ignored: ['the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'I', 'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at', 'this', 'but', 'his', 'by', 'from', 'they', 'we', 'say', 'her', 'she', 'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their', 'what', 'so', 'up', 'out', 'if', 'about', 'who', 'get', 'which', 'go', 'me', 'when', 'make', 'can', 'like', 'time', 'no', 'just', 'him', 'know', 'take', 'person', 'into', 'year', 'your', 'good', 'some', 'could', 'them', 'see', 'other', 'than', 'then', 'now', 'look', 'only', 'come', 'its', 'over', 'think', 'also', 'back', 'after', 'use', 'two', 'how', 'our', 'work', 'first', 'well', 'way', 'even', 'new', 'want', 'because', 'any', 'these', 'give', 'day', 'most', 'us', 'were', 'was', 'has', 'less', 'more', 'is', 's', 'said', 'between', 'without', 'are', 'been', 'such', 'did', 'both', 'had', 'still', 'within']
  },
  init: function(el, opts) {
    var avg, binhash, binrange, bins, clusters, diff, hash, i, ignored, k, key, line, max, min, minkey, minval, numofwords, o, obj, occurences, out, re, score, sum, tagnumber, text, token, v, word, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4;
    ignored = opts['ignored'];
    text = $(el).text();
    clusters = opts['clusters'];
    bins = clusters.length;
    tagnumber = opts['max'];
    for (_i = 0, _len = ignored.length; _i < _len; _i++) {
      word = ignored[_i];
      re = new RegExp("\\b" + word + "\\b", "gi");
      text = text.replace(re, '');
    }
    numofwords = 0;
    occurences = [];
    _ref = text.split("\n");
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      line = _ref[_j];
      _ref1 = line.split(/\W+/);
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        token = _ref1[_k];
        word = "#" + (token.toLowerCase());
        if (!parseFloat(word) && word.length > 1) {
          numofwords = numofwords + 1;
          if (occurences[word]) {
            occurences[word] = parseInt(occurences[word] + 1);
          } else {
            occurences[word] = 1;
          }
        }
      }
    }
    sum = 0;
    for (k in occurences) {
      v = occurences[k];
      occurences[k] = occurences[k] / numofwords;
      sum += occurences[k];
    }
    avg = sum / numofwords;
    occurences = (function(occurences) {
      var keys, res, _l, _len3;
      res = {};
      keys = Object.keys(occurences).sort(function(a, b) {
        return occurences[b] - occurences[a];
      });
      for (_l = 0, _len3 = keys.length; _l < _len3; _l++) {
        k = keys[_l];
        if (occurences[k] > avg) {
          res[k] = occurences[k];
        }
      }
      return res;
    })(occurences);
    max = -1;
    min = 1000;
    out = Object.keys(occurences).slice(0, +tagnumber + 1 || 9e9);
    hash = {};
    for (_l = 0, _len3 = out.length; _l < _len3; _l++) {
      o = out[_l];
      if (min > (occurences[o] * 100)) {
        min = occurences[o] * 100;
      }
      if (max < (occurences[o] * 100)) {
        max = occurences[o] * 100;
      }
      hash[o] = occurences[o] * 100;
    }
    diff = max - min;
    binrange = diff / bins;
    binhash = [];
    for (i = _m = 0, _ref2 = bins - 1; 0 <= _ref2 ? _m <= _ref2 : _m >= _ref2; i = 0 <= _ref2 ? ++_m : --_m) {
      binhash[min + (i * binrange)] = [];
    }
    _ref3 = Object.keys(hash);
    for (_n = 0, _len4 = _ref3.length; _n < _len4; _n++) {
      k = _ref3[_n];
      score = hash[k];
      minval = 1000;
      minkey = 0;
      for (i = _o = 0, _ref4 = bins - 1; 0 <= _ref4 ? _o <= _ref4 : _o >= _ref4; i = 0 <= _ref4 ? ++_o : --_o) {
        key = min + (i * binrange);
        if (Math.abs(key - score) < minval) {
          minval = Math.abs(key - score);
          minkey = key;
        }
      }
      binhash[minkey].push(k);
    }
    return obj = $(el).find('.tags-extracted').each(function(i, obj) {
      var b, c, cstyle, label, tag, _len5, _p, _ref5, _results;
      c = 0;
      $(obj).empty();
      $(obj).append("TAGS:");
      _ref5 = Object.keys(binhash).reverse();
      _results = [];
      for (_p = 0, _len5 = _ref5.length; _p < _len5; _p++) {
        k = _ref5[_p];
        b = binhash[k];
        cstyle = clusters[c];
        c = c + 1;
        _results.push((function() {
          var _len6, _q, _results1;
          _results1 = [];
          for (_q = 0, _len6 = b.length; _q < _len6; _q++) {
            tag = b[_q];
            label = $('<span>').attr({
              "class": "label " + cstyle
            }).append(tag);
            _results1.push($(obj).append(label));
          }
          return _results1;
        })());
      }
      return _results;
    });
  }
});
